Supongamos que diseñamos un sistema para una cafetería que ofrece una gran variedad de bebidas, como café, té, refrescos, batidos, entre otras. Cada bebida puede presentarse en diferentes variantes, por ejemplo: distintos tamaños (pequeño, mediano, grande), tipos de leche (entera, descremada, sin lactosa), saborizantes, temperatura, etc.
En este contexto, el patrón Flyweight puede resultar útil para gestionar las propiedades que son comunes entre las distintas variantes de bebidas. Por ejemplo, podrías definir una clase Bebida como interfaz general, y luego crear clases específicas como Café, Té o Refresco, que implementen dicha interfaz.
Además, podrías incorporar una fábrica de bebidas encargada de administrar las instancias creadas. El patrón Flyweight se utilizaría para compartir atributos comunes entre las variantes, como el nombre de la bebida, su precio base o la disponibilidad de ingredientes recurrentes.
Por ejemplo, un café con leche y un café solo compartirían la misma información base del café (nombre, precio inicial, ingredientes fundamentales como el café en sí), mientras que características particulares como el tamaño o el tipo de leche se manejarían externamente al objeto flyweight, ya sea pasándolas como parámetros o almacenándolas por separado.
Este enfoque permite optimizar el uso de memoria al evitar la creación repetida de objetos con datos idénticos, y en su lugar, compartir esos datos entre las diferentes variantes de bebidas.